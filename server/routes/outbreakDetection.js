const express = require('express');
const router = express.Router();
const outbreakAlerts = require('../data/outbreakAlerts.json');
const { translateText, getCachedTranslation } = require('../utils/translator');
const logger = require('../utils/logger');
const twilio = require('twilio');

// Initialize Twilio client for alerts
let twilioClient;
try {
  if (process.env.TWILIO_ACCOUNT_SID && process.env.TWILIO_AUTH_TOKEN) {
    twilioClient = twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN);
  }
} catch (error) {
  console.warn('Twilio not configured, outbreak alert features will be limited');
}

// In-memory storage for outbreak detection (in production, use database)
const symptomClusters = new Map();
const outbreakReports = new Map();
const subscribedUsers = new Map(); // Users subscribed to outbreak alerts

// Outbreak detection thresholds
const OUTBREAK_THRESHOLDS = {
  fever: { cases: 5, timeWindow: 7 * 24 * 60 * 60 * 1000 }, // 5 cases in 7 days
  diarrhea: { cases: 3, timeWindow: 3 * 24 * 60 * 60 * 1000 }, // 3 cases in 3 days
  respiratory: { cases: 4, timeWindow: 5 * 24 * 60 * 60 * 1000 }, // 4 cases in 5 days
  rash: { cases: 3, timeWindow: 7 * 24 * 60 * 60 * 1000 }, // 3 cases in 7 days
  default: { cases: 3, timeWindow: 5 * 24 * 60 * 60 * 1000 } // Default threshold
};

// Disease patterns for outbreak detection
const DISEASE_PATTERNS = {
  dengue: {
    symptoms: ['fever', 'headache', 'rash', 'fatigue'],
    season: 'monsoon',
    vector: 'mosquito',
    threshold: { cases: 3, timeWindow: 7 * 24 * 60 * 60 * 1000 }
  },
  malaria: {
    symptoms: ['fever', 'headache', 'fatigue', 'vomiting'],
    season: 'monsoon',
    vector: 'mosquito',
    threshold: { cases: 3, timeWindow: 7 * 24 * 60 * 60 * 1000 }
  },
  diarrheal_outbreak: {
    symptoms: ['diarrhea', 'vomiting', 'abdominal_pain'],
    cause: 'waterborne',
    threshold: { cases: 3, timeWindow: 3 * 24 * 60 * 60 * 1000 }
  },
  respiratory_outbreak: {
    symptoms: ['cough', 'fever', 'difficulty_breathing'],
    transmission: 'airborne',
    threshold: { cases: 4, timeWindow: 5 * 24 * 60 * 60 * 1000 }
  }
};

// Analyze symptom patterns for outbreak detection
const analyzeSymptomPatterns = (location, timeWindow = 7 * 24 * 60 * 60 * 1000) => {
  const now = new Date();
  const cutoffTime = new Date(now.getTime() - timeWindow);
  
  const locationClusters = symptomClusters.get(location) || [];
  const recentCases = locationClusters.filter(cluster => 
    new Date(cluster.timestamp) > cutoffTime
  );
  
  // Group by symptom combinations
  const symptomGroups = new Map();
  
  recentCases.forEach(caseData => {
    const symptomKey = caseData.symptoms.sort().join(',');
    if (!symptomGroups.has(symptomKey)) {
      symptomGroups.set(symptomKey, []);
    }
    symptomGroups.get(symptomKey).push(caseData);
  });
  
  // Check for potential outbreaks
  const potentialOutbreaks = [];
  
  symptomGroups.forEach((cases, symptomKey) => {
    const symptoms = symptomKey.split(',');
    
    // Check against disease patterns
    Object.entries(DISEASE_PATTERNS).forEach(([diseaseId, pattern]) => {
      const matchScore = calculateSymptomMatch(symptoms, pattern.symptoms);
      
      if (matchScore > 0.6 && cases.length >= pattern.threshold.cases) {
        potentialOutbreaks.push({
          diseaseId,
          disease: diseaseId.replace('_', ' ').toUpperCase(),
          symptoms: symptoms,
          caseCount: cases.length,
          matchScore: matchScore,
          cases: cases,
          severity: cases.length >= pattern.threshold.cases * 2 ? 'high' : 'medium',
          pattern: pattern
        });
      }
    });
    
    // Check general symptom clustering
    const primarySymptom = symptoms[0];
    const threshold = OUTBREAK_THRESHOLDS[primarySymptom] || OUTBREAK_THRESHOLDS.default;
    
    if (cases.length >= threshold.cases) {
      potentialOutbreaks.push({
        diseaseId: `${primarySymptom}_cluster`,
        disease: `${primarySymptom.toUpperCase()} CLUSTER`,
        symptoms: symptoms,
        caseCount: cases.length,
        matchScore: 1.0,
        cases: cases,
        severity: cases.length >= threshold.cases * 2 ? 'high' : 'medium',
        pattern: { threshold }
      });
    }
  });
  
  return potentialOutbreaks;
};

// Calculate symptom match score
const calculateSymptomMatch = (reportedSymptoms, patternSymptoms) => {
  const matches = reportedSymptoms.filter(symptom => 
    patternSymptoms.includes(symptom)
  ).length;
  
  return matches / patternSymptoms.length;
};

// Generate outbreak alert message
const generateOutbreakAlert = (outbreak, location, language = 'en') => {
  const alertMessages = {
    dengue: {
      english: `ЁЯЪи DENGUE OUTBREAK ALERT: ${outbreak.caseCount} cases detected in ${location}. Use mosquito nets, remove stagnant water, seek medical help for fever.`,
      hindi: `ЁЯЪи рдбреЗрдВрдЧреВ рдкреНрд░рдХреЛрдк рдЕрд▓рд░реНрдЯ: ${location} рдореЗрдВ ${outbreak.caseCount} рдорд╛рдорд▓реЗ рдорд┐рд▓реЗред рдордЪреНрдЫрд░рджрд╛рдиреА рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░реЗрдВ, рд░реБрдХрд╛ рдкрд╛рдиреА рд╣рдЯрд╛рдПрдВ, рдмреБрдЦрд╛рд░ рдХреЗ рд▓рд┐рдП рдЪрд┐рдХрд┐рддреНрд╕рд╛ рд╕рд╣рд╛рдпрддрд╛ рд▓реЗрдВред`,
      bengali: `ЁЯЪи ржбрзЗржЩрзНржЧрзБ ржкрзНрж░рж╛ржжрзБрж░рзНржнрж╛ржм рж╕рждрж░рзНржХрждрж╛: ${location} ржП ${outbreak.caseCount}ржЯрж┐ ржХрзЗрж╕ ржкрж╛ржУржпрж╝рж╛ ржЧрзЗржЫрзЗред ржорж╢рж╛рж░рж┐ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржи, ржЬржорж╛ ржкрж╛ржирж┐ рж╕рж░рж╛ржи, ржЬрзНржмрж░рзЗрж░ ржЬржирзНржп ржЪрж┐ржХрж┐рзОрж╕рж╛ ржирж┐ржиред`,
      assamese: `ЁЯЪи ржбрзЗржВржЧрзБ ржкрзНрз░рж╛ржжрзБрз░рзНржнрж╛рз▒ рж╕рждрз░рзНржХржмрж╛ржгрзА: ${location} ржд ${outbreak.caseCount}ржЯрж╛ ржХрзЗржЫ ржкрзЛрз▒рж╛ ржЧрзИржЫрзЗред ржорж╣ржЬрж╛рж▓ ржмрзНржпрз▒рж╣рж╛рз░ ржХрз░ржХ, ржЬржорж╛ ржкрж╛ржирзА ржЖржБрждрз░рж╛ржУржХ, ржЬрзНржмрз░рз░ ржмрж╛ржмрзЗ ржЪрж┐ржХрж┐рзОрж╕рж╛ рж▓ржУржХред`,
      telugu: `ЁЯЪи р░бр▒Жр░Вр░Чр▒Нр░пр▒В р░╡р▒Нр░пр░╛р░кр▒Нр░др░┐ р░╣р▒Жр░Ър▒Нр░Ър░░р░┐р░Х: ${location}р░▓р▒Л ${outbreak.caseCount} р░Хр▒Зр░╕р▒Бр░▓р▒Б р░Хр░ир▒Бр░Чр▒Кр░ир░мр░бр▒Нр░бр░╛р░пр░┐. р░жр▒Лр░ор░др▒Жр░░р░▓р▒Б р░╡р░╛р░бр░Вр░бр░┐, р░ир░┐р░▓р░┐р░Ър░┐р░и р░ир▒Ар░░р▒Б р░др▒Кр░▓р░Чр░┐р░Вр░Ър░Вр░бр░┐, р░Ьр▒Нр░╡р░░р░╛р░ир░┐р░Хр░┐ р░╡р▒Ир░жр▒Нр░п р░╕р░╣р░╛р░пр░В р░др▒Ар░╕р▒Бр░Хр▒Лр░Вр░бр░┐.`
    },
    malaria: {
      english: `ЁЯжЯ MALARIA OUTBREAK ALERT: ${outbreak.caseCount} cases in ${location}. Sleep under treated nets, clear water logging, get tested for fever.`,
      hindi: `ЁЯжЯ рдорд▓реЗрд░рд┐рдпрд╛ рдкреНрд░рдХреЛрдк рдЕрд▓рд░реНрдЯ: ${location} рдореЗрдВ ${outbreak.caseCount} рдорд╛рдорд▓реЗред рдЙрдкрдЪрд╛рд░рд┐рдд рдЬрд╛рд▓ рдХреЗ рдиреАрдЪреЗ рд╕реЛрдПрдВ, рдкрд╛рдиреА рдХрд╛ рдЬрдорд╛рд╡ рд╕рд╛рдл рдХрд░реЗрдВ, рдмреБрдЦрд╛рд░ рдХреА рдЬрд╛рдВрдЪ рдХрд░рд╛рдПрдВред`,
      bengali: `ЁЯжЯ ржорзНржпрж╛рж▓рзЗрж░рж┐ржпрж╝рж╛ ржкрзНрж░рж╛ржжрзБрж░рзНржнрж╛ржм рж╕рждрж░рзНржХрждрж╛: ${location} ржП ${outbreak.caseCount}ржЯрж┐ ржХрзЗрж╕ред ржЪрж┐ржХрж┐рзОрж╕рж┐ржд ржЬрж╛рж▓рзЗрж░ ржирж┐ржЪрзЗ ржШрзБржорж╛ржи, ржкрж╛ржирж┐ ржЬржорж╛ ржкрж░рж┐рж╖рзНржХрж╛рж░ ржХрж░рзБржи, ржЬрзНржмрж░рзЗрж░ ржкрж░рзАржХрзНрж╖рж╛ ржХрж░рж╛ржиред`,
      assamese: `ЁЯжЯ ржорзЗрж▓рзЗрз░рж┐ржпрж╝рж╛ ржкрзНрз░рж╛ржжрзБрз░рзНржнрж╛рз▒ рж╕рждрз░рзНржХржмрж╛ржгрзА: ${location} ржд ${outbreak.caseCount}ржЯрж╛ ржХрзЗржЫред ржЪрж┐ржХрж┐рзОрж╕рж┐ржд ржЬрж╛рж▓рз░ рждрж▓ржд рж╢рзБржУржХ, ржкрж╛ржирзА ржЬржорж╛ ржкрз░рж┐рж╖рзНржХрж╛рз░ ржХрз░ржХ, ржЬрзНржмрз░рз░ ржкрз░рзАржХрзНрж╖рж╛ ржХрз░рж╛ржУржХред`,
      telugu: `ЁЯжЯ р░ор░▓р▒Зр░░р░┐р░пр░╛ р░╡р▒Нр░пр░╛р░кр▒Нр░др░┐ р░╣р▒Жр░Ър▒Нр░Ър░░р░┐р░Х: ${location}р░▓р▒Л ${outbreak.caseCount} р░Хр▒Зр░╕р▒Бр░▓р▒Б. р░Ър░┐р░Хр░┐р░др▒Нр░╕р░┐р░д р░╡р░▓р░▓ р░Хр░┐р░Вр░ж р░ир░┐р░жр▒Нр░░р░┐р░Вр░Ър░Вр░бр░┐, р░ир▒Ар░░р▒Б р░Ьр░о р░Ър▒Зр░пр░Хр░Вр░бр░┐, р░Ьр▒Нр░╡р░░р░╛р░ир░┐р░Хр░┐ р░кр░░р▒Ар░Хр▒Нр░╖р░▓р▒Б р░Ър▒Зр░пр░┐р░Вр░Ър▒Бр░Хр▒Лр░Вр░бр░┐.`
    },
    diarrheal_outbreak: {
      english: `ЁЯТз DIARRHEA OUTBREAK ALERT: ${outbreak.caseCount} cases in ${location}. Boil water before drinking, maintain hygiene, use ORS for dehydration.`,
      hindi: `ЁЯТз рджрд╕реНрдд рдкреНрд░рдХреЛрдк рдЕрд▓рд░реНрдЯ: ${location} рдореЗрдВ ${outbreak.caseCount} рдорд╛рдорд▓реЗред рдкреАрдиреЗ рд╕реЗ рдкрд╣рд▓реЗ рдкрд╛рдиреА рдЙрдмрд╛рд▓реЗрдВ, рд╕реНрд╡рдЪреНрдЫрддрд╛ рдмрдирд╛рдП рд░рдЦреЗрдВ, рдирд┐рд░реНрдЬрд▓реАрдХрд░рдг рдХреЗ рд▓рд┐рдП ORS рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░реЗрдВред`,
      bengali: `ЁЯТз ржбрж╛ржпрж╝рж░рж┐ржпрж╝рж╛ ржкрзНрж░рж╛ржжрзБрж░рзНржнрж╛ржм рж╕рждрж░рзНржХрждрж╛: ${location} ржП ${outbreak.caseCount}ржЯрж┐ ржХрзЗрж╕ред ржкрж╛ржирж┐ ржлрзБржЯрж┐ржпрж╝рзЗ ржкрж╛ржи ржХрж░рзБржи, рж╕рзНржмрж╛рж╕рзНржерзНржпржмрж┐ржзрж┐ ржорзЗржирзЗ ржЪрж▓рзБржи, ржкрж╛ржирж┐рж╢рзВржирзНржпрждрж╛рж░ ржЬржирзНржп ORS ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржиред`,
      assamese: `ЁЯТз ржбрж╛ржпрж╝рзЗрз░рж┐ржпрж╝рж╛ ржкрзНрз░рж╛ржжрзБрз░рзНржнрж╛рз▒ рж╕рждрз░рзНржХржмрж╛ржгрзА: ${location} ржд ${outbreak.caseCount}ржЯрж╛ ржХрзЗржЫред ржкрж╛ржирзА ржЙрждрж▓рж╛ржЗ ржЦрж╛ржУржХ, рж╕рзНржмрж╛рж╕рзНржерзНржпржмрж┐ржзрж┐ ржорж╛ржирж┐ ржЪрж▓ржХ, ржкрж╛ржирзАрж╢рзВржирзНржпрждрж╛рз░ ржмрж╛ржмрзЗ ORS ржмрзНржпрз▒рж╣рж╛рз░ ржХрз░ржХред`,
      telugu: `ЁЯТз р░Ер░др░┐р░╕р░╛р░░ р░╡р▒Нр░пр░╛р░кр▒Нр░држ┐ р░╣р▒Жр░Ър▒Нр░Ър░░р░┐р░Х: ${location}р░▓р▒Л ${outbreak.caseCount} р░Хр▒Зр░╕р▒Бр░▓р▒Б. р░ир▒Ар░░р▒Б р░ор░░р░┐р░Чр░┐р░Вр░Ър░┐ р░др░╛р░Чр░Вр░бр░┐, р░кр░░р░┐р░╢р▒Бр░нр▒Нр░░р░д р░кр░╛р░Яр░┐р░Вр░Ър░Вр░бр░┐, р░ир░┐р░░р▒Нр░Ьр░▓р▒Ар░Хр░░р░гр░Хр▒Б ORS р░╡р░╛р░бр░Вр░бр░┐.`
    },
    default: {
      english: `тЪая╕П HEALTH ALERT: Unusual increase in ${outbreak.disease} cases (${outbreak.caseCount}) detected in ${location}. Please take precautions and seek medical advice.`,
      hindi: `тЪая╕П рд╕реНрд╡рд╛рд╕реНрдереНрдп рдЕрд▓рд░реНрдЯ: ${location} рдореЗрдВ ${outbreak.disease} рдХреЗ рдорд╛рдорд▓реЛрдВ (${outbreak.caseCount}) рдореЗрдВ рдЕрд╕рд╛рдорд╛рдиреНрдп рд╡реГрджреНрдзрд┐ред рдХреГрдкрдпрд╛ рд╕рд╛рд╡рдзрд╛рдиреА рдмрд░рддреЗрдВ рдФрд░ рдЪрд┐рдХрд┐рддреНрд╕рд╛ рд╕рд▓рд╛рд╣ рд▓реЗрдВред`,
      bengali: `тЪая╕П рж╕рзНржмрж╛рж╕рзНржерзНржп рж╕рждрж░рзНржХрждрж╛: ${location} ржП ${outbreak.disease} ржХрзЗрж╕рзЗрж░ (${outbreak.caseCount}) ржЕрж╕рзНржмрж╛ржнрж╛ржмрж┐ржХ ржмрзГржжрзНржзрж┐ред ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ рж╕рждрж░рзНржХрждрж╛ ржЕржмрж▓ржорзНржмржи ржХрж░рзБржи ржПржмржВ ржЪрж┐ржХрж┐рзОрж╕рж╛ ржкрж░рж╛ржорж░рзНрж╢ ржирж┐ржиред`,
      assamese: `тЪая╕П рж╕рзНржмрж╛рж╕рзНржерзНржп рж╕рждрз░рзНржХржмрж╛ржгрзА: ${location} ржд ${outbreak.disease} ржХрзЗржЫрз░ (${outbreak.caseCount}) ржЕрж╕рзНржмрж╛ржнрж╛рз▒рж┐ржХ ржмрзГржжрзНржзрж┐ред ржЕржирзБржЧрзНрз░рж╣ ржХрз░рж┐ рж╕рждрз░рзНржХрждрж╛ ржЕрз▒рж▓ржорзНржмржи ржХрз░ржХ ржЖрз░рзБ ржЪрж┐ржХрж┐рзОрж╕рж╛ ржкрз░рж╛ржорз░рзНрж╢ рж▓ржУржХред`,
      telugu: `тЪая╕П р░Жр░░р▒Лр░Чр▒Нр░п р░╣р▒Жр░Ър▒Нр░Ър░░р░┐р░Х: ${location}р░▓р▒Л ${outbreak.disease} р░Хр▒Зр░╕р▒Бр░▓ (${outbreak.caseCount}) р░Ер░╕р░╛р░зр░╛р░░р░г р░кр▒Жр░░р▒Бр░Чр▒Бр░жр░▓. р░жр░пр░Ър▒Зр░╕р░┐ р░Ьр░╛р░Чр▒Нр░░р░др▒Нр░др░▓р▒Б р░др▒Ар░╕р▒Бр░Хр▒Лр░Вр░бр░┐ р░ор░░р░┐р░пр▒Б р░╡р▒Ир░жр▒Нр░п р░╕р░▓р░╣р░╛ р░др▒Ар░╕р▒Бр░Хр▒Лр░Вр░бр░┐.`
    }
  };
  
  const diseaseKey = outbreak.diseaseId.includes('dengue') ? 'dengue' :
                   outbreak.diseaseId.includes('malaria') ? 'malaria' :
                   outbreak.diseaseId.includes('diarrheal') ? 'diarrheal_outbreak' : 'default';
  
  return alertMessages[diseaseKey][language] || alertMessages[diseaseKey].english;
};

// Send outbreak alerts to subscribed users
const sendOutbreakAlerts = async (outbreak, location, language = 'en') => {
  try {
    if (!twilioClient) {
      logger.warn('Twilio not configured, cannot send outbreak alerts');
      return false;
    }
    
    const alertMessage = generateOutbreakAlert(outbreak, location, language);
    const locationSubscribers = Array.from(subscribedUsers.values())
      .filter(user => user.location === location || user.location === 'all');
    
    let sentCount = 0;
    
    for (const subscriber of locationSubscribers.slice(0, 100)) { // Limit to prevent spam
      try {
        await twilioClient.messages.create({
          body: alertMessage,
          from: process.env.TWILIO_PHONE_NUMBER,
          to: subscriber.phone
        });
        
        sentCount++;
      } catch (error) {
        logger.error(`Failed to send outbreak alert to ${subscriber.phone}:`, error);
      }
    }
    
    logger.info(`Outbreak alert sent to ${sentCount} subscribers for ${location}`);
    return sentCount > 0;
    
  } catch (error) {
    logger.error('Send outbreak alerts error:', error);
    return false;
  }
};

// POST /api/outbreak-detection/report - Report symptoms for outbreak detection
router.post('/report', async (req, res) => {
  try {
    const { symptoms, location, patientInfo, language = 'en' } = req.body;
    
    if (!symptoms || !Array.isArray(symptoms) || !location) {
      return res.status(400).json({
        error: 'Symptoms array and location are required',
        success: false
      });
    }
    
    // Create symptom report for clustering
    const reportId = `OUT_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const report = {
      id: reportId,
      symptoms: symptoms.map(s => s.toLowerCase()),
      location: location,
      patientInfo: patientInfo || {},
      timestamp: new Date().toISOString(),
      language: language
    };
    
    // Add to location cluster
    if (!symptomClusters.has(location)) {
      symptomClusters.set(location, []);
    }
    symptomClusters.get(location).push(report);
    
    // Analyze for potential outbreaks
    const potentialOutbreaks = analyzeSymptomPatterns(location);
    
    // Check if any outbreak threshold is crossed
    const newOutbreaks = [];
    for (const outbreak of potentialOutbreaks) {
      const outbreakKey = `${location}_${outbreak.diseaseId}`;
      
      if (!outbreakReports.has(outbreakKey)) {
        // New outbreak detected
        const outbreakReport = {
          id: `OUTBREAK_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          location: location,
          disease: outbreak.disease,
          diseaseId: outbreak.diseaseId,
          caseCount: outbreak.caseCount,
          severity: outbreak.severity,
          symptoms: outbreak.symptoms,
          detectedAt: new Date().toISOString(),
          status: 'active',
          alertsSent: 0
        };
        
        outbreakReports.set(outbreakKey, outbreakReport);
        newOutbreaks.push(outbreakReport);
        
        // Send alerts
        const alertsSent = await sendOutbreakAlerts(outbreak, location, language);
        outbreakReport.alertsSent = alertsSent ? 1 : 0;
        
        logger.info(`New outbreak detected: ${outbreak.disease} in ${location}`);
      }
    }
    
    res.json({
      success: true,
      reportId: reportId,
      location: location,
      potentialOutbreaks: potentialOutbreaks.length,
      newOutbreaksDetected: newOutbreaks.length,
      outbreaks: newOutbreaks.map(outbreak => ({
        id: outbreak.id,
        disease: outbreak.disease,
        caseCount: outbreak.caseCount,
        severity: outbreak.severity
      })),
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    logger.error('Outbreak detection report error:', error);
    res.status(500).json({
      error: 'Failed to process outbreak detection report',
      success: false
    });
  }
});

// GET /api/outbreak-detection/outbreaks - Get active outbreaks
router.get('/outbreaks', async (req, res) => {
  try {
    const { location, severity, language = 'en' } = req.query;
    
    let outbreaks = Array.from(outbreakReports.values())
      .filter(outbreak => outbreak.status === 'active');
    
    if (location) {
      outbreaks = outbreaks.filter(outbreak => 
        outbreak.location.toLowerCase().includes(location.toLowerCase())
      );
    }
    
    if (severity) {
      outbreaks = outbreaks.filter(outbreak => outbreak.severity === severity);
    }
    
    // Sort by detection time (newest first)
    outbreaks.sort((a, b) => new Date(b.detectedAt) - new Date(a.detectedAt));
    
    // Add alert messages
    const outbreaksWithAlerts = outbreaks.map(outbreak => ({
      ...outbreak,
      alertMessage: generateOutbreakAlert(outbreak, outbreak.location, language)
    }));
    
    res.json({
      success: true,
      outbreaks: outbreaksWithAlerts,
      totalOutbreaks: outbreaks.length,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    logger.error('Get outbreaks error:', error);
    res.status(500).json({
      error: 'Failed to get outbreak information',
      success: false
    });
  }
});

// POST /api/outbreak-detection/subscribe - Subscribe to outbreak alerts
router.post('/subscribe', async (req, res) => {
  try {
    const { phone, location, language = 'en', name } = req.body;
    
    if (!phone) {
      return res.status(400).json({
        error: 'Phone number is required',
        success: false
      });
    }
    
    const subscriber = {
      phone: phone,
      location: location || 'all',
      language: language,
      name: name || 'Unknown',
      subscribedAt: new Date().toISOString(),
      active: true
    };
    
    subscribedUsers.set(phone, subscriber);
    
    logger.info(`User subscribed to outbreak alerts: ${phone} for ${location}`);
    
    res.json({
      success: true,
      message: 'Successfully subscribed to outbreak alerts',
      subscription: {
        phone: phone,
        location: location || 'all',
        language: language
      },
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    logger.error('Subscribe to outbreak alerts error:', error);
    res.status(500).json({
      error: 'Failed to subscribe to outbreak alerts',
      success: false
    });
  }
});

// POST /api/outbreak-detection/unsubscribe - Unsubscribe from outbreak alerts
router.post('/unsubscribe', async (req, res) => {
  try {
    const { phone } = req.body;
    
    if (!phone) {
      return res.status(400).json({
        error: 'Phone number is required',
        success: false
      });
    }
    
    const wasSubscribed = subscribedUsers.has(phone);
    subscribedUsers.delete(phone);
    
    logger.info(`User unsubscribed from outbreak alerts: ${phone}`);
    
    res.json({
      success: true,
      message: wasSubscribed ? 'Successfully unsubscribed from outbreak alerts' : 'Phone number was not subscribed',
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    logger.error('Unsubscribe from outbreak alerts error:', error);
    res.status(500).json({
      error: 'Failed to unsubscribe from outbreak alerts',
      success: false
    });
  }
});

// GET /api/outbreak-detection/stats - Get outbreak detection statistics
router.get('/stats', async (req, res) => {
  try {
    const totalReports = Array.from(symptomClusters.values())
      .reduce((sum, cluster) => sum + cluster.length, 0);
    
    const activeOutbreaks = Array.from(outbreakReports.values())
      .filter(outbreak => outbreak.status === 'active').length;
    
    const totalSubscribers = subscribedUsers.size;
    
    // Outbreak severity distribution
    const severityCount = { high: 0, medium: 0, low: 0 };
    Array.from(outbreakReports.values())
      .filter(outbreak => outbreak.status === 'active')
      .forEach(outbreak => {
        severityCount[outbreak.severity] = (severityCount[outbreak.severity] || 0) + 1;
      });
    
    // Most affected locations
    const locationCounts = new Map();
    Array.from(outbreakReports.values())
      .filter(outbreak => outbreak.status === 'active')
      .forEach(outbreak => {
        const count = locationCounts.get(outbreak.location) || 0;
        locationCounts.set(outbreak.location, count + 1);
      });
    
    const topLocations = Array.from(locationCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([location, count]) => ({ location, outbreaks: count }));
    
    res.json({
      success: true,
      statistics: {
        totalReports,
        activeOutbreaks,
        totalSubscribers,
        severityDistribution: severityCount,
        topAffectedLocations: topLocations,
        detectionRate: totalReports > 0 ? ((activeOutbreaks / totalReports) * 100).toFixed(2) : 0
      },
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    logger.error('Get outbreak detection statistics error:', error);
    res.status(500).json({
      error: 'Failed to get outbreak detection statistics',
      success: false
    });
  }
});

module.exports = router;